#安全编程技术
##类加载器是什么？
##类加载器的委托模式？
##单子模式？仅有一个对象
###单子模式{
1、私有构造方法
2、指向自己实例的静态引用
3、以自己实例为返回值的公有方法
}
```
    no public but private
    private static Single s = new Single();
    public static Single get_single() {
        return s;
    }  
```
###静态方法只能调用静态属性（主要是由对象生成顺序所导致的）
###单子模式的优点：节省内存
###构建新的对象耗费资源
###什么时候用全静态方法？什么时候用单子模式？
###程序加载顺序：静态->非静态
###全静态就会导致系统耗费大量资源
```ArrayList```动态数组，不记录数据类型，用Object存储
###构造方法
```ArrayList mylist = new ArrayList();```
```add()```方法添加元素
```get()```方法返回元素

###泛型不接收继承
###单子模式在多线程中的问题

###进程和线程的概念

进程(process)：是指在系统中正在运行的一个应用程序，系统资源分配的基本单位，在内存中有其完备的数据空间和代码空间，拥有完整的虚拟空间地址。一个进程所拥有的数据和变量只属于它自己。

线程(thread)：进程内部相对独立的可执行单元， 也被称为轻量进程，操作系统中进行任务调度的基本单元，它与父进程的其它线程共享该进程所拥有的全部代码空间和全局变量，拥有独立的堆栈（局部变量对于线程来说是私有的）.

线程消耗资源少，能多线程就不多进程；

线程能做到进程做不到的事

一个线程可以创建和撤销另一个线程

#锁旗标（可以理解为通行证，只能有一个线程持有）

关键字```synchronized```对所有线程来说是独一无二的，加锁例如```synchronized(---.class)```

实验：用```synchronized```实现多线程售票程序


死锁：线程等待不可能被释放的锁，从而导致工作无法完成

###接口是纯粹的抽象类

抽象类内的抽象方法可以实现，但接口不行

###对异常的理解

普通异常：能够猜测可能的异常

运行异常：无法提前解决

###一个java类只能有一个父类，但可以实现多个接口

```Exception```所有异常类的父类，分为运行时异常和普通异常

```Class.forname(ObjectName)```中类名必须存在，否则会产生异常，这种是编译器运行之前就能判断出来的异常，也即是普通异常，会要求程序员对可能会出现的异常进行处理

```RuntimeException```编译器运行之前无法捕获异常，但是在编译运行的时候出现了异常

###考点
常见的几种异常？
运行时异常和普通异常的区别？

运行时异常：都是```RuntimeException```类及其子类异常，```NullPointerException```(空指针异常)、```IndexOutofException```（下标越界异常）

普通异常：
```Error```程序无法处理的错误

```HashMap<Integer, HashSet<Integer>>```

实验：五个运行异常

缓存池 0-127

```equals```方法不仅仅是用来比较内容的，同时也是用来实现自己业务逻辑的，比如```StringBuffer```中的```equals```的方法是从```Object```中继承的，如果没有自己实现的话默认使用的是```==```方法









